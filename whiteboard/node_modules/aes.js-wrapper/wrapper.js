const crypto = require('crypto')

class AESWrapper
{
  
  /**
   * The constructor method in this class is completely useless, it's not used for anything.
   */
  constructor ()
  {}
  
  /**
   * Encrypt normal text to a very uniqe, and very secure hex formatted string.
   * @param {string} text This is the text to encrypt.
   * @param {string} password This is the raw text utf8 password to hash into a md5 hex that will also secure the encryption better.
   * @returns {string}
   * @example
   * AESWrapper.encrypt('hello world', 'very secret password')
   * // '39f425031f850fcca2f0f4f56bf3143a8104fa1dd27eb143f64a4fd3f223b85ca6b5849a5b48e6dd4af9fb6ddba9ffbae41c4d165491f8358ae7167d7acc834e58cf97fbab413aef0165ea991a475809'
   */
  encrypt (text, raw)
  {
    var password = this.md5(raw)
      ,   raw_iv = this.getRandomBytes(16)
      ,   cipher = crypto.createCipheriv('aes-256-cbc', password, raw_iv)
      ,     data = cipher.update(text, 'utf-8', 'hex') + cipher.final('hex')
      
      , iv = this.hex(raw_iv)
      , ciph = crypto.createCipheriv('aes-256-cbc', password, this._iv_)
      , final = ciph.update(data + '@' + iv, 'utf-8', 'hex') + ciph.final('hex')
    
    return final
  }
  
  /**
   * Decrypt encrypted text to the normal text using the very secret password.
   * @param {string} encrypted This is the encrypted text to decrypt
   * @param {string} password This is the raw text utf8 password to hash into a md5 hex that will also secure the encryption better.
   * @returns {string|boolean}
   * @example
   * AESWrapper.decrypt('39f425031f850fcca2f0f4f56bf3143a8104fa1dd27eb143f64a4fd3f223b85ca6b5849a5b48e6dd4af9fb6ddba9ffbae41c4d165491f8358ae7167d7acc834e58cf97fbab413aef0165ea991a475809', 'very secret password')
   * // 'hello world'
   */
  decrypt (text, raw)
  {
    try {
      var password = this.md5(raw)
        , ciph = crypto.createDecipheriv('aes-256-cbc', password, this._iv_)
        , data = ciph.update(text, 'hex', 'utf-8') + ciph.final('utf-8')
        
        , iv = this.buffer(data.split('@')[1])
        , raw = data.split('@')[0]
        
        , cipher = crypto.createDecipheriv('aes-256-cbc', password, iv)
        , final = cipher.update(raw, 'hex', 'utf-8') + cipher.final('utf-8')
      
      return final
    } catch (e) {
      return false
    }
  }
  
  /**
   * Hash text into a completely uniqe hash, that means hashing the same string again won't be equal to this one.
   * @param {string} key This key will be used to create the hash, this key will be encrypting dummy text.
   * @returns {string}
   * @example
   * AESWrapper.hash('Hello World')
   * // c6ae556bd9a4d728f061ff66cd196e96e00792810061a528db8f4f74f229c60dc9bfc837fbe447eadb7c6353ffce18983849c70ffc7ac754ee3d2502ddc148827032ea83741d9647a6a2e8921cb1800c192381fe42d357de64d397c4e10c0b2eeee18d2255a7817cb36bb9ee97c17fb84ad48da3b2902d3b0953a357f6d0b9720c117474ea2bdf3cc9212645403f6ed94f8106cfb2db4b755ae15c3652721a108654fff81c06379fd092794dea8455019212cd25a983146cb8472049bba75d9a4e5777484c4360dabc233d6fa4c9923a
   */
  hash (key)
  {
    return this.encrypt(this.dummyText, key)
  }
  
  /**
   * Check if a hash is valid by decrypting dummy text.
   * @param {string} hash This is the hash to match against, simply try to decrypt this hash into the dummy text and check if the decryption was successful.
   * @param {string} key This key will be used to decrypt the hash into dummy text.
   * @returns {boolean}
   * @example
   * AESWrapper.val('c6ae556bd9a4d728f061ff66cd196e96e00792810061a528db8f4f74f229c60dc9bfc837fbe447eadb7c6353ffce18983849c70ffc7ac754ee3d2502ddc148827032ea83741d9647a6a2e8921cb1800c192381fe42d357de64d397c4e10c0b2eeee18d2255a7817cb36bb9ee97c17fb84ad48da3b2902d3b0953a357f6d0b9720c117474ea2bdf3cc9212645403f6ed94f8106cfb2db4b755ae15c3652721a108654fff81c06379fd092794dea8455019212cd25a983146cb8472049bba75d9a4e5777484c4360dabc233d6fa4c9923a', 'Hello World')
   * // true
   */
  val (hash, key)
  {
    return this.decrypt(hash, key) !== false ? true : false
  }
  
  /**
   * This is used to get a random IV, this also makes the encryption uniqe and very secure.
   * @param {stirng} length This defines how many bytes that will be generated.
   * @returns {Buffer}
   */
  getRandomBytes (l)
  {
    return crypto.randomBytes(l)
  }
  
  /**
   * This turns a buffer into a string
   * @param {Buffer} buffer The buffer the encode.
   * @returns {string}
   */
  hex (buffer)
  {
    return buffer.toString('hex')
  }
  
  /**
   * Decode HEX into a buffer.
   * @param {string} hex The hex data to decode.
   * @returns {Buffer}
   */
  buffer (hex)
  {
    return Buffer.from(hex, 'hex')
  }
  
  /**
   * Hash text into a md5 hash.
   * @param {string} text The text to hash to an MD5 hash.
   * @returns {string}
   * @example
   * AESWrapper.md5('hello world')
   * // '5EB63BBBE01EEED093CB22BB8F5ACDC3'
   */
  md5 (text)
  {
    return crypto
      .createHash('md5')
      .update(text, 'utf-8')
      .digest('hex')
      .toUpperCase()
  }
  
  /**
   * Get the default IV in a buffer.
   * @type {Buffer}
   */
  get _iv_ ()
  { 
    return this.buffer('f124385fb0990e5fde684f67b5d80833')
  }
  
  /**
   * This is the default dummy text to use when hashing and validating hashes
   * @type {string}
   */
  get dummyText ()
  {
    return 'Hello! This is some epic pieces of dummy text, simply used for hashing.'
  }
}

module.exports = new AESWrapper()